/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.sitata.googleauthutil;

import java.io.IOException;
import java.util.HashMap;
import java.util.logging.Logger;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.util.TiActivityResultHandler;
import org.appcelerator.titanium.util.TiActivitySupport;

import android.accounts.AccountManager;
import android.app.Activity;
import android.app.Dialog;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.google.android.gms.auth.GoogleAuthException;
import com.google.android.gms.auth.GoogleAuthUtil;
import com.google.android.gms.auth.GooglePlayServicesAvailabilityException;
import com.google.android.gms.auth.UserRecoverableAuthException;
import com.google.android.gms.common.AccountPicker;
import com.google.android.gms.common.GooglePlayServicesUtil;

@Kroll.module(name = "TitaniumGoogleAuthUtil", id = "com.sitata.googleauthutil")
public class TitaniumGoogleAuthUtilModule extends KrollModule implements
		TiActivityResultHandler
{
	static final int REQUEST_CODE_PICK_ACCOUNT = 1000;

	// Standard Debugging variables
	private static final String TAG = "TiGoogleAuthUtilModule";
	protected int requestCode;
	protected int recoveryRequestCode;
	// private static final String SCOPE =
	// "oauth2:https://www.googleapis.com/auth/userinfo.profile";
	// private static final String SCOPE = "oauth2:profile email";
	private String[] mScopes;
	private String mEmail;
	private String mServerId;
	private KrollFunction successCallback;
	private KrollFunction errorCallback;

	// picker is closed without choosing an account
	@Kroll.constant
	public static final String PICKER_CLOSED = "tgau:pickerClosed";
	// could be network is down
	@Kroll.constant
	public static final String IO_EXCEPTION = "tgau:ioException";
	// If user intervention is required to provide consent, enter a password,
	// etc, a UserRecoverableAuthException will be thrown
	@Kroll.constant
	public static final String USER_RECOVERABLE_EXCEPTION = "tgau:recoverException";
	// Some other type of unrecoverable exception has occurred.
	// Report and log the error as appropriate for your app.
	@Kroll.constant
	public static final String FATAL_EXCEPTION = "tgau:fatalException";
	// Error when launching activity for picker
	@Kroll.constant
	public static final String ACTIVITY_ERROR = "tgau:activityError";
	// No email given so we can't fetch token
	@Kroll.constant
	public static final String NO_EMAIL = "tgau:noEmailError";

	public TitaniumGoogleAuthUtilModule()
	{
		super();
		mScopes = new String[]{""};
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		Logger.getLogger(TAG).info("inside onAppCreate");
	}

	// Methods
	@Kroll.method
	public void signin(KrollDict props)
	{
		if (props.containsKey("success")) {
			successCallback = (KrollFunction) props.get("success");
		}
		if (props.containsKey("error")) {
			errorCallback = (KrollFunction) props.get("error");
		}
		

		String[] accountTypes = new String[] { GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE };
		Intent intent = AccountPicker.newChooseAccountIntent(null, null,
				accountTypes, false, null, null, null, null);

		Activity activity = TiApplication.getAppCurrentActivity();
		TiActivitySupport support = (TiActivitySupport) activity;
		requestCode = support.getUniqueResultCode();
		support.launchActivityForResult(intent, requestCode, this);

	}

	@Kroll.getProperty @Kroll.method
	public void setServerId(String value)
	{
		mServerId = value;
	}

	@Kroll.getProperty @Kroll.method
	public String getServerId() {
		return mServerId;
	}

	@Kroll.getProperty @Kroll.method
	public void setScopes(String[] value)
	{
		mScopes = value;
	}

	@Kroll.getProperty @Kroll.method
	public String[] getScopes() {
		return mScopes;
	}

	@Override
	public void onError(Activity activity, int requestCode, Exception e) {
		Logger.getLogger(TAG).info("ON ERROR called.");
		handleError(ACTIVITY_ERROR);
	}

	@Override
	public void onResult(Activity activity, int thisRequestCode,
			int resultCode, Intent data) {
		Logger.getLogger(TAG).info(
				"On Result - Request Code is:" + thisRequestCode);

		if (errorCallback == null || successCallback == null)
			return;

		if (thisRequestCode == requestCode) {
			Logger.getLogger(TAG).info(
					"Handling Fetch User Token Request Code.");
			// Receiving a result from the AccountPicker
			if (resultCode == Activity.RESULT_OK) {

				mEmail = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME);
				// With the account name acquired, go get the auth token
				getUserToken();
			} else if (resultCode == Activity.RESULT_CANCELED) {
				// The account picker dialog closed without selecting an
				// account.
				handleError(PICKER_CLOSED);
			}
		} else if (thisRequestCode == recoveryRequestCode) {
			Logger.getLogger(TAG).info("Handling Recovery Request Result.");
			if (resultCode == Activity.RESULT_OK) {
				Bundle extra = data.getExtras();
				String oneTimeToken = extra.getString("authtoken");
				handleSignInSuccess(mEmail, oneTimeToken);
			}
		}
	}

	private void handleSignInSuccess(String email, String token) {
		HashMap<String, String> event = new HashMap<String, String>();
		event.put("accountId", email);
		event.put("accessToken", token);
		successCallback.call(getKrollObject(), event);

	}

	public void handleTokenError(String errorCode) {
		handleError(errorCode);
	}

	public void handleRecoverableException(Intent recoveryIntent) {
		Logger.getLogger(TAG).info("Launchng recoverable intent.");

		// Use the intent in a custom dialog or just startActivityForResult.
		Activity activity = TiApplication.getAppCurrentActivity();
		TiActivitySupport support = (TiActivitySupport) activity;
		recoveryRequestCode = support.getUniqueResultCode();
		support.launchActivityForResult(recoveryIntent, recoveryRequestCode,
				this);

	}

	// Google play is probably not available
	// TODO: Test this...
	public void handleGooglePlayException(
			GooglePlayServicesAvailabilityException playEx) {
		// Use the dialog to present to the user.
		Activity activity = TiApplication.getAppCurrentActivity();
		Dialog dialog = GooglePlayServicesUtil.getErrorDialog(
				playEx.getConnectionStatusCode(), activity, requestCode);
		dialog.show();
	}

	private void getUserToken() {
		if (mEmail == null) {
			handleError(NO_EMAIL);
		} else {
			String scopeStr = TextUtils.join(" ", mScopes);
			
			FetchUserTokenTask task = new FetchUserTokenTask(TiApplication.getAppCurrentActivity(), 
					mEmail, scopeStr, mServerId);
			task.execute();
		}
	}

	private void handleError(String code) {
		HashMap<String, String> event = new HashMap<String, String>();
		event.put("error", code);
		errorCallback.call(getKrollObject(), event);
	}
	
	
	
	public class FetchUserTokenTask extends AsyncTask {
		Activity mActivity;
		String mScope;
		String mEmail;
		String mServerId;
		private static final String TAG = "TiGoogleAuthUtilModule";

		FetchUserTokenTask(Activity activity, String name, String scope, String serverId) {
			this.mActivity = activity;
			this.mScope = scope;
			this.mEmail = name;
			this.mServerId = serverId;
		}

		/**
		 * Executes the asynchronous job. This runs when you call execute() on
		 * the AsyncTask instance.
		 */
		@Override
		protected Object doInBackground(Object... arg0) {
			try {
				String token = fetchToken();
				if (token != null) {
					Log.d(TAG,
							"Found token for email: " + mEmail + " - " + token);
					handleSignInSuccess(mEmail, token);
				}
			} catch (IOException e) {
				// The fetchToken() method handles Google-specific exceptions,
				// so this indicates something went wrong at a higher level.
				// TIP: Check for network connectivity before starting the
				// AsyncTask.
				Log.d(TAG, "IOException: " + e.getMessage());
				handleError(IO_EXCEPTION);
			}
			return null;
		}

		/**
		 * Gets an authentication token from Google and handles any
		 * GoogleAuthException that may occur.
		 */
		protected String fetchToken() throws IOException {
			try {
				Log.d(TAG,
						"Fetching token from google using account: '" + mEmail
								+ "' and scope: '" + mScope + "'.");
				
				// Not the app's client ID.
				String scopes = "oauth2:server:client_id:" + mServerId + ":api_scope:" + mScope; 
				
				Log.d(TAG, "Total scope: " + scopes);
				return GoogleAuthUtil.getToken(mActivity, mEmail, scopes);
			} catch (GooglePlayServicesAvailabilityException playEx) {
				Logger.getLogger(TAG).info(
						"Google Play Exception: " + playEx.getMessage());
				handleGooglePlayException(playEx);
			} catch (UserRecoverableAuthException userRecoverableException) {
				Logger.getLogger(TAG).info(
						"User Recoverable Exception: "
								+ userRecoverableException.getMessage());
				handleRecoverableException(userRecoverableException
						.getIntent());
			} catch (GoogleAuthException fatalException) {
				Logger.getLogger(TAG).info(
						"Fatal Exception: " + fatalException.getMessage());
				handleError(FATAL_EXCEPTION);
			}
			return null;
		}

	}


}

